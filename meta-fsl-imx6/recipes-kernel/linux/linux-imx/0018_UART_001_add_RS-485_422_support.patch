Add RS-485/422 support


diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index d557f1e..935dbc9 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -54,6 +54,18 @@
 #include <linux/platform_data/serial-imx.h>
 #include <linux/platform_data/dma-imx.h>
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#include <asm/uaccess.h>
+
+#define UMCR  0xb8 /* UART RS-485 Mode Control Register */
+#define UMCR_SLADDR_SHF 8       /* RS-485 slave address shift */
+#define UMCR_SLADDR_MASK	 0xFF  /* RS-485 slave address is 8 bits wide */
+#define UMCR_SADEN	 (1<<3)  /* RS-485 slave address detected interrupt enable */
+#define UMCR_TXB8	 (1<<2)  /* Transmit RS-485 bit 8 */
+#define UMCR_SLAM	 (1<<1)  /* RS-485 slave address detect mode selection */
+#define UMCR_MDEN	 (1<<0)  /* RS-485 mode enable */
+#endif
+
 /* Register definitions */
 #define URXD0 0x0  /* Receiver Register */
 #define URTX0 0x40 /* Transmitter Register */
@@ -250,6 +262,10 @@ struct imx_port {
 	unsigned int            saved_reg[11];
 #define DMA_TX_IS_WORKING 1
 	unsigned long		flags;
+#ifdef CONFIG_ARCH_ADVANTECH
+	/* RS-485 fields */
+	struct serial_rs485	rs485;
+#endif
 };
 
 struct imx_port_ucrs {
@@ -322,6 +338,83 @@ static inline int is_imx6q_uart(struct imx_port *sport)
 {
 	return sport->devdata->devtype == IMX6Q_UART;
 }
+
+#ifdef CONFIG_ARCH_ADVANTECH
+/*
+ * RS-485
+ */
+#define USE_RS485(sport) ((sport)->rs485.flags & SER_RS485_ENABLED)
+#define SLADDR 0xA5
+
+static void imx_rs485_stop_tx(struct imx_port *imx_uart_port)
+{
+	unsigned int temp;
+
+	temp = readl(imx_uart_port->port.membase + UCR2);
+	temp &= ~UCR2_CTS;
+	writel(temp, imx_uart_port->port.membase + UCR2);
+}
+
+static void imx_rs485_start_tx(struct imx_port *imx_uart_port)
+{
+	unsigned int temp;
+
+	temp = readl(imx_uart_port->port.membase + UCR2);
+	temp |= UCR2_CTS;
+	writel(temp, imx_uart_port->port.membase + UCR2);
+}
+
+/* 
+ * Enable or disable RS-485 support
+ */
+void imx_rs485_config(struct uart_port *port, struct serial_rs485 *rs485conf)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	unsigned long flags;
+	unsigned int temp;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* copy rs485 structure */
+	sport->rs485 = *rs485conf;
+
+	if (rs485conf->flags & SER_RS485_ENABLED) {
+		//printk(KERN_INFO "\nSet UART to RS-485\n");
+		/* Ignore RTS pin and set CTS as receiver mode by default */
+		temp = readl(port->membase + UCR2);
+		temp |= UCR2_IRTS;
+		temp &= ~UCR2_CTSC;
+		temp &= ~UCR2_CTS;
+		writel(temp, port->membase + UCR2);
+#if 0
+		/* Set UMCR for 9 bit RS-485 mode */
+		temp = readl(port->membase + UMCR);
+		temp &= ~(UMCR_SLADDR_MASK << UMCR_SLADDR_SHF);
+		temp |= SLADDR << UMCR_SLADDR_SHF;
+		temp &= ~UMCR_TXB8;
+		temp |= (UMCR_SADEN | UMCR_SLAM | UMCR_MDEN);
+		writel(temp, port->membase + UMCR);
+#endif
+	} else {
+		//printk(KERN_INFO "\nSet UART to RS-232\n");
+		/* Enable CTS Pin Control */
+		temp = readl(port->membase + UCR2);
+		temp &= ~UCR2_IRTS;
+		temp |= UCR2_CTSC;
+		writel(temp, port->membase + UCR2);
+#if 0
+		/* Set UMCR back to RS-232 */
+		temp = readl(port->membase + UMCR);
+		temp &= ~(UMCR_SLADDR_MASK << UMCR_SLADDR_SHF);
+		temp &= ~(UMCR_SADEN | UMCR_TXB8 | UMCR_SLAM | UMCR_MDEN);
+		writel(temp, port->membase + UMCR);
+#endif
+	}
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+#endif
+
 /*
  * Save and restore functions for UCR1, UCR2 and UCR3 registers
  */
@@ -398,7 +491,11 @@ static void imx_stop_tx(struct uart_port *port)
 	struct imx_port *sport = (struct imx_port *)port;
 	unsigned long temp;
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_IRDA(sport) || USE_RS485(sport)) {
+#else
 	if (USE_IRDA(sport)) {
+#endif
 		/* half duplex - wait for end of transmission */
 		int n = 256;
 		while ((--n > 0) &&
@@ -406,6 +503,11 @@ static void imx_stop_tx(struct uart_port *port)
 			udelay(5);
 			barrier();
 		}
+#ifdef CONFIG_ARCH_ADVANTECH
+		if (USE_RS485(sport)) {
+			imx_rs485_stop_tx(sport);
+		}
+#endif
 		/*
 		 * irda transceiver - wait a bit more to avoid
 		 * cutoff, hardware dependent
@@ -606,7 +708,11 @@ static void imx_start_tx(struct uart_port *port)
 	struct imx_port *sport = (struct imx_port *)port;
 	unsigned long temp;
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_IRDA(sport) || USE_RS485(sport)) {
+#else
 	if (USE_IRDA(sport)) {
+#endif
 		/* half duplex in IrDA mode; have to disable receive mode */
 		temp = readl(sport->port.membase + UCR4);
 		temp &= ~(UCR4_DREN);
@@ -628,8 +734,11 @@ static void imx_start_tx(struct uart_port *port)
 		temp = readl(sport->port.membase + UCR1);
 		writel(temp | UCR1_TXMPTYEN, sport->port.membase + UCR1);
 	}
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_IRDA(sport) || USE_RS485(sport)) {
+#else
 	if (USE_IRDA(sport)) {
+#endif
 		temp = readl(sport->port.membase + UCR1);
 		temp |= UCR1_TRDYEN;
 		writel(temp, sport->port.membase + UCR1);
@@ -638,7 +747,11 @@ static void imx_start_tx(struct uart_port *port)
 		temp |= UCR4_TCEN;
 		writel(temp, sport->port.membase + UCR4);
 	}
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_RS485(sport)) {
+		imx_rs485_start_tx(sport);
+	}
+#endif
 	if (sport->dma_is_enabled) {
 		schedule_delayed_work(&sport->tsk_dma_tx, 0);
 		return;
@@ -839,6 +952,10 @@ static void imx_set_mctrl(struct uart_port *port, unsigned int mctrl)
 	struct imx_port *sport = (struct imx_port *)port;
 	unsigned long temp;
 
+#ifdef CONFIG_ARCH_ADVANTECH
+	if (USE_RS485(sport))
+		return;
+#endif
 	temp = readl(sport->port.membase + UCR2) & ~(UCR2_CTS | UCR2_CTSC);
 	if (mctrl & TIOCM_RTS)
 		temp |= UCR2_CTS | UCR2_CTSC;
@@ -1347,7 +1464,14 @@ static void imx_shutdown(struct uart_port *port)
 		if (pdata->irda_enable)
 			pdata->irda_enable(0);
 	}
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	/* Turn back to RS-232 when the port closes */
+	if (USE_RS485(sport)) {
+		imx_rs485_stop_tx(sport);
+		sport->rs485.flags &= ~SER_RS485_ENABLED;
+		imx_rs485_config(port, &sport->rs485);
+	}
+#endif
 	/*
 	 * Stop our timer.
 	 */
@@ -1638,6 +1762,38 @@ imx_verify_port(struct uart_port *port, struct serial_struct *ser)
 	return ret;
 }
 
+#ifdef CONFIG_ARCH_ADVANTECH
+/*
+ * Handle TIOCSRS485 & TIOCSRS485 ioctl for RS-485 support
+ */
+static int imx_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	struct serial_rs485 rs485conf;
+	struct imx_port *sport = (struct imx_port *)port;
+
+	switch (cmd) {
+		case TIOCSRS485:
+			if (copy_from_user(&rs485conf,
+			    (struct serial_rs485 *) arg,
+			    sizeof(rs485conf)))
+				return -EFAULT;
+			imx_rs485_config(port, &rs485conf);
+			break;
+
+		case TIOCGRS485:
+			if (copy_to_user((struct serial_rs485 *) arg,
+			    &(sport->rs485),
+			    sizeof(rs485conf)))
+				return -EFAULT;
+			break;
+
+		default:
+			return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+#endif
+
 #if defined(CONFIG_CONSOLE_POLL)
 static int imx_poll_get_char(struct uart_port *port)
 {
@@ -1718,6 +1874,9 @@ static struct uart_ops imx_pops = {
 	.type		= imx_type,
 	.config_port	= imx_config_port,
 	.verify_port	= imx_verify_port,
+#if defined(CONFIG_ARCH_ADVANTECH)
+	.ioctl		= imx_ioctl,
+#endif
 #if defined(CONFIG_CONSOLE_POLL)
 	.poll_get_char  = imx_poll_get_char,
 	.poll_put_char  = imx_poll_put_char,
-- 
1.7.9.5

