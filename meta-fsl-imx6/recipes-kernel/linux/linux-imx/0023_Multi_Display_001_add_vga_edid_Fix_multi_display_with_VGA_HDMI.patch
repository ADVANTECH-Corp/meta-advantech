From 3219c9122dab2c9b343016040c0b4a9f47513c66 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Tue, 14 Jun 2016 15:00:24 +0800
Subject: [PATCH 1/2] 11


diff --git a/drivers/video/fbdev/mxc/Kconfig b/drivers/video/fbdev/mxc/Kconfig
index 801da76..f255871 100644
--- a/drivers/video/fbdev/mxc/Kconfig
+++ b/drivers/video/fbdev/mxc/Kconfig
@@ -18,6 +18,11 @@ config FB_MXC_SYNC_PANEL
 	depends on FB_MXC
 	tristate "Synchronous Panel Framebuffer"
 
+config FB_MXC_SYNC_PANEL_EDID
+	depends on FB_MXC_SYNC_PANEL && ARCH_ADVANTECH
+	tristate "VGA Panel EDID Parser"
+	default n
+
 config FB_MXC_MIPI_DSI
 	tristate "MXC MIPI_DSI"
 	depends on FB_MXC_SYNC_PANEL
@@ -86,3 +91,7 @@ config FB_MXC_EINK_V2_PANEL
 config FB_MXC_EINK_AUTO_UPDATE_MODE
 	bool "E-Ink Auto-update Mode Support"
 	depends on FB_MXC_EINK_PANEL
+
+config FB_MXC_CH7055
+	depends on FB_MXC_SYNC_PANEL && ARCH_ADVANTECH
+	tristate "Chrontel CH7055 VGA Interface Chip"
diff --git a/drivers/video/fbdev/mxc/Makefile b/drivers/video/fbdev/mxc/Makefile
index c91711c..333b2e4 100644
--- a/drivers/video/fbdev/mxc/Makefile
+++ b/drivers/video/fbdev/mxc/Makefile
@@ -10,3 +10,4 @@ obj-$(CONFIG_FB_MXC_EINK_V2_PANEL)		+= mxc_epdc_v2_fb.o
 obj-$(CONFIG_FB_MXS_SII902X) += mxsfb_sii902x.o
 obj-$(CONFIG_FB_MXC_DCIC) += mxc_dcic.o
 obj-$(CONFIG_HANNSTAR_CABC) += hannstar_cabc.o
+obj-$(CONFIG_FB_MXC_CH7055) += mxcfb_ch7055.o
diff --git a/drivers/video/fbdev/mxc/mxc_hdmi.c b/drivers/video/fbdev/mxc/mxc_hdmi.c
index c1b5126..98fcdc3 100644
--- a/drivers/video/fbdev/mxc/mxc_hdmi.c
+++ b/drivers/video/fbdev/mxc/mxc_hdmi.c
@@ -54,6 +54,10 @@
 
 #include <linux/mfd/mxc-hdmi-core.h>
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#include <linux/proc-board.h>
+#endif
+
 #define DISPDRV_HDMI	"hdmi"
 #define HDMI_EDID_LEN		512
 
@@ -868,33 +872,6 @@ static void hdmi_phy_i2c_write(struct mxc_hdmi *hdmi, unsigned short data,
 	hdmi_phy_wait_i2c_done(hdmi, 1000);
 }
 
-#if 0
-static unsigned short hdmi_phy_i2c_read(struct mxc_hdmi *hdmi,
-					unsigned char addr)
-{
-	unsigned short data;
-	unsigned char msb = 0, lsb = 0;
-	hdmi_writeb(0xFF, HDMI_IH_I2CMPHY_STAT0);
-	hdmi_writeb(addr, HDMI_PHY_I2CM_ADDRESS_ADDR);
-	hdmi_writeb(HDMI_PHY_I2CM_OPERATION_ADDR_READ,
-		HDMI_PHY_I2CM_OPERATION_ADDR);
-	hdmi_phy_wait_i2c_done(hdmi, 1000);
-	msb = hdmi_readb(HDMI_PHY_I2CM_DATAI_1_ADDR);
-	lsb = hdmi_readb(HDMI_PHY_I2CM_DATAI_0_ADDR);
-	data = (msb << 8) | lsb;
-	return data;
-}
-
-static int hdmi_phy_i2c_write_verify(struct mxc_hdmi *hdmi, unsigned short data,
-				     unsigned char addr)
-{
-	unsigned short val = 0;
-	hdmi_phy_i2c_write(hdmi, data, addr);
-	val = hdmi_phy_i2c_read(hdmi, addr);
-	return (val == data);
-}
-#endif
-
 static bool  hdmi_edid_wait_i2c_done(struct mxc_hdmi *hdmi, int msec)
 {
     unsigned char val = 0;
@@ -1198,13 +1175,42 @@ static int hdmi_phy_configure(struct mxc_hdmi *hdmi, unsigned char pRep,
 
 	hdmi_phy_i2c_write(hdmi, 0x0000, 0x13);  /* PLLPHBYCTRL */
 	hdmi_phy_i2c_write(hdmi, 0x0006, 0x17);
-	/* RESISTANCE TERM 133Ohm Cfg */
-	hdmi_phy_i2c_write(hdmi, 0x0005, 0x19);  /* TXTERM */
-	/* PREEMP Cgf 0.00 */
-	hdmi_phy_i2c_write(hdmi, 0x800d, 0x09);  /* CKSYMTXCTRL */
-	/* TX/CK LVL 10 */
-	hdmi_phy_i2c_write(hdmi, 0x01ad, 0x0E);  /* VLEVCTRL */
-
+#ifdef CONFIG_ARCH_ADVANTECH
+	if ( IS_ROM_3420 || IS_ROM_5420 )
+	{
+		if(hdmi->fbi->var.yres == 480)
+		{
+			/* PLL/MPLL Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x1EA0, 0x06);
+			/* PREEMP Cgf 0.00 */
+			hdmi_phy_i2c_write(hdmi, 0x8009, 0x09);  /* CKSYMTXCTRL */
+			/* TX/CK LVL 10 */
+			hdmi_phy_i2c_write(hdmi, 0x02B5, 0x0E);  /* VLEVCTRL */
+			/* RESISTANCE TERM 133Ohm Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x0, 0x19);  /* TXTERM */
+		}
+		else
+		{
+			/* PLL/MPLL Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x0AA0, 0x06);
+			/* PREEMP Cgf 0.00 */
+			hdmi_phy_i2c_write(hdmi, 0x800D, 0x09);  /* CKSYMTXCTRL */
+			/* TX/CK LVL 10 */
+			hdmi_phy_i2c_write(hdmi, 0x00C6, 0x0E);  /* VLEVCTRL */
+			/* RESISTANCE TERM 133Ohm Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x0004, 0x19);  /* TXTERM */
+		}
+	}
+	else
+#endif
+	{
+		/* RESISTANCE TERM 133Ohm Cfg */
+		hdmi_phy_i2c_write(hdmi, 0x0005, 0x19);  /* TXTERM */
+		/* PREEMP Cgf 0.00 */
+		hdmi_phy_i2c_write(hdmi, 0x800d, 0x09);  /* CKSYMTXCTRL */
+		/* TX/CK LVL 10 */
+		hdmi_phy_i2c_write(hdmi, 0x01ad, 0x0E);  /* VLEVCTRL */
+	}
 	/* Board specific setting for PHY register 0x09, 0x0e to pass HCT */
 	if (hdmi->phy_config.reg_cksymtx != 0)
 		hdmi_phy_i2c_write(hdmi, hdmi->phy_config.reg_cksymtx, 0x09);
diff --git a/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c b/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c
index e61ef67..110accd 100644
--- a/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c
@@ -61,6 +61,11 @@
 
 /* Display port number */
 #define MXCFB_PORT_NUM	2
+
+#ifdef CONFIG_ARCH_ADVANTECH
+char fb_vga_fix_id[30];
+#endif
+
 /*!
  * Structure containing the MXC specific framebuffer information.
  */
@@ -3029,8 +3034,32 @@ static int mxcfb_dispdrv_init(struct platform_device *pdev,
 
 	dev_info(&pdev->dev, "registered mxc display driver %s\n", disp_dev);
 
+#ifdef CONFIG_ARCH_ADVANTECH
+  /* dirty! need to fix */
+	if(!strcmp(disp_dev, "lcd"))
+	{
+		char bg0_id[] = "DISP3 BG";
+		char bg1_id[] = "DISP3 BG - DI1";
+		char fg_id[] = "DISP3 FG";
+
+		if (mxcfbi->ipu_di == 0) {
+			bg0_id[4] += mxcfbi->ipu_id;
+			strcpy(fb_vga_fix_id, bg0_id);
+		} else if (mxcfbi->ipu_di == 1) {
+			bg1_id[4] += mxcfbi->ipu_id;
+			strcpy(fb_vga_fix_id, bg1_id);
+		} else { /* Overlay */
+			fg_id[4] += mxcfbi->ipu_id;
+			strcpy(fb_vga_fix_id, fg_id);
+		}
+		printk("*****VGA fb name %s", fb_vga_fix_id);
+	}
+#endif
 	return ret;
 }
+#ifdef CONFIG_ARCH_ADVANTECH
+EXPORT_SYMBOL_GPL(fb_vga_fix_id);
+#endif
 
 /*
  * Parse user specified options (`video=trident:')
@@ -3521,11 +3550,17 @@ static int mxcfb_probe(struct platform_device *pdev)
 		mxcfbi->ipu_ch_nf_irq = IPU_IRQ_BG_SYNC_NFACK;
 		mxcfbi->ipu_alp_ch_irq = IPU_IRQ_BG_ALPHA_SYNC_EOF;
 		mxcfbi->ipu_ch = MEM_BG_SYNC;
+
+#ifdef CONFIG_ARCH_ADVANTECH
+		/* Unblank all the fb by default */
+		mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_UNBLANK;
+#else
 		/* Unblank the primary fb only by default */
 		if (pdev->id == 0)
 			mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_UNBLANK;
 		else
 			mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_POWERDOWN;
+#endif
 
 		ret = mxcfb_register(fbi);
 		if (ret < 0)
diff --git a/drivers/video/fbdev/mxc/mxc_lcdif.c b/drivers/video/fbdev/mxc/mxc_lcdif.c
index 59d429c..0039224 100644
--- a/drivers/video/fbdev/mxc/mxc_lcdif.c
+++ b/drivers/video/fbdev/mxc/mxc_lcdif.c
@@ -22,6 +22,288 @@
 
 #include "mxc_dispdrv.h"
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#ifdef CONFIG_FB_MXC_SYNC_PANEL_EDID
+#include <linux/kthread.h>
+#include <video/mxc_edid.h>
+#include <linux/console.h>
+#include <linux/ipu-v3.h>
+
+//extern int enabled_video_mode_ext;
+//extern int solo_display;
+extern char fb_vga_fix_id[30];
+u8 edid[512];
+static struct mxc_edid_cfg edid_cfg;
+static struct fb_info *fbi = NULL;
+static struct task_struct *task_kthread;
+#define POLLING_WAIT_TIME_MS    3000
+static struct i2c_client *vga_i2c;
+static int vga_i2c_initialized = 0;
+extern const struct fb_videomode mxc_cea_mode[64];
+int first_init_flag = 1;
+
+static const struct fb_videomode xga_mode = {
+	/* 13 1024x768-60 VESA */
+	NULL, 60, 1024, 768, 15384, 160, 24, 29, 3, 136, 6,
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA
+};
+
+static const struct fb_videomode sxga_mode = {
+	/* 20 1280x1024-60 VESA */
+	NULL, 60, 1280, 1024, 9259, 248, 48, 38, 1, 112, 3,
+	FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA
+};
+
+void vga_edid_rebuild_modelist(void)
+{
+	struct fb_videomode m;
+	const struct fb_videomode *mode;
+	int i;
+
+	console_lock();
+	//Only Destory the old EDID list when video extension is enabled
+	//if (enabled_video_mode_ext || solo_display)
+		fb_destroy_modelist(&fbi->modelist);
+
+	for (i = 0; i < fbi->monspecs.modedb_len; i++)
+	{
+		//not support interface display and bitrate over 170Mhz
+		if (!(fbi->monspecs.modedb[i].vmode & FB_VMODE_INTERLACED) && (fbi->monspecs.modedb[i].pixclock > 5882))
+		{
+			/*
+			printk( "Added mode %d:", i);
+			printk("xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				fbi->monspecs.modedb[i].xres,
+				fbi->monspecs.modedb[i].yres,
+				fbi->monspecs.modedb[i].refresh,
+				fbi->monspecs.modedb[i].vmode,
+				fbi->monspecs.modedb[i].flag);
+			*/
+			fb_add_videomode(&fbi->monspecs.modedb[i], &fbi->modelist);
+		}
+	}
+	console_unlock();
+
+	fb_var_to_videomode(&m, &fbi->var);
+
+	mode = fb_find_nearest_mode(&m, &fbi->modelist);
+
+	if(!mode)
+	{
+		printk("%s: could not find mode in modelist\n", __func__);
+	}
+	else if (fb_mode_is_equal(&m, mode))
+	{
+		printk("vga: video mode is same as previous\n");
+	}
+	else
+	{
+		fb_videomode_to_var(&fbi->var, mode);
+
+		fbi->var.activate |= FB_ACTIVATE_FORCE;
+		console_lock();
+		fbi->flags |= FBINFO_MISC_USEREVENT;
+		fb_set_var(fbi, &fbi->var);
+		fbi->flags &= ~FBINFO_MISC_USEREVENT;
+		console_unlock();
+	}
+}
+
+void vga_default_modelist(void)
+{
+	const struct fb_videomode *temp_mode;
+	struct fb_videomode m;
+	const struct fb_videomode *mode;
+	int i;
+
+	console_lock();
+	//Only Destory the old EDID list when video extension is enabled
+	//if (enabled_video_mode_ext || solo_display)
+		fb_destroy_modelist(&fbi->modelist);
+
+	/*Add all no interlaced CEA mode to default modelist */
+	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
+		temp_mode = &mxc_cea_mode[i];
+		if (!(temp_mode->vmode & FB_VMODE_INTERLACED) && (temp_mode->pixclock > 5882))
+		{
+			/*
+			printk( "Added default mode %d:", i);
+			printk("xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				temp_mode->xres,
+				temp_mode->yres,
+				temp_mode->refresh,
+				temp_mode->vmode,
+				temp_mode->flag);
+			*/
+			fb_add_videomode(temp_mode, &fbi->modelist);
+		}
+	}
+
+	/*Add XGA and SXGA to default modelist */
+	fb_add_videomode(&xga_mode, &fbi->modelist);
+
+	/*
+	printk( "Added default mode XGA:");
+	printk("xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				xga_mode.xres,
+				xga_mode.yres,
+				xga_mode.refresh,
+				xga_mode.vmode,
+				xga_mode.flag);
+	*/
+
+	fb_add_videomode(&sxga_mode, &fbi->modelist);
+
+	/*
+	printk( "Added default mode SXGA:");
+	printk("xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				sxga_mode.xres,
+				sxga_mode.yres,
+				sxga_mode.refresh,
+				sxga_mode.vmode,
+				sxga_mode.flag);
+	*/
+
+	console_unlock();
+
+	fb_var_to_videomode(&m, &fbi->var);
+	mode = fb_find_nearest_mode(&m, &fbi->modelist);
+
+	if(!mode)
+	{
+		printk("%s: could not find mode in modelist\n", __func__);
+	}
+	else if (fb_mode_is_equal(&m, mode))
+	{
+		printk("vga: video mode is same as previous\n");
+	}
+	else
+	{
+		fb_videomode_to_var(&fbi->var, mode);
+
+		fbi->var.activate |= FB_ACTIVATE_FORCE;
+		console_lock();
+		fbi->flags |= FBINFO_MISC_USEREVENT;
+		fb_set_var(fbi, &fbi->var);
+		fbi->flags &= ~FBINFO_MISC_USEREVENT;
+		console_unlock();
+	}
+}
+
+static int vga_edid_work(void *data)
+{
+	int wake_up_flag = 0;
+	wait_queue_head_t wait;
+	init_waitqueue_head(&wait);
+
+	while(1)
+	{
+		int i, j, ret;
+		u8 edid_old[512];
+
+		for (i = 0; i < num_registered_fb; i++)
+		{
+			if (strcmp(registered_fb[i]->fix.id, fb_vga_fix_id) == 0)
+			{
+				fbi = registered_fb[i];
+
+				/* back up edid  */
+				memcpy(edid_old, edid, 512);
+
+				ret = mxc_edid_read(vga_i2c->adapter, vga_i2c->addr, edid, &edid_cfg, fbi);
+
+				if (ret < 0)
+				{
+					memcpy(edid, edid_old, 512);
+					//printk("vga: read edid failed\n");
+					if(first_init_flag) {
+						vga_default_modelist();
+					}
+				}
+				else if(!memcmp(edid_old, edid, 512))
+				{
+					//printk("vga: same edid\n");
+				}
+				else if(fbi->monspecs.modedb_len == 0)
+				{
+					printk("vga:no modes read from edid\n");
+				}
+				else
+				{
+					/* receive new edid */
+					printk("vga: new edid\n");
+					/*
+					for (j = 0; j < 512/16; j++)
+					{
+						for (i = 0; i < 16; i++)
+						printk("0x%02X ", edid[j*16 + i]);
+						printk("\n");
+					}
+					*/
+					vga_edid_rebuild_modelist();
+				}
+
+				if(first_init_flag) {
+					first_init_flag = 0;
+				}
+			}
+		}
+
+		wait_event_interruptible_timeout(wait, wake_up_flag == 1, msecs_to_jiffies(POLLING_WAIT_TIME_MS));
+	}
+	return 0;
+}
+
+static int mxc_vga_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE | I2C_FUNC_I2C))
+		return -ENODEV;
+	printk("**********mxc_vga_i2c_probe\n");
+	vga_i2c = client;
+	vga_i2c_initialized = 1;
+
+	return 0;
+}
+
+static int mxc_vga_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id mxc_vga_i2c_id[] = {
+	{ "mxc_vga_i2c", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, mxc_vga_i2c_id);
+
+static struct i2c_driver mxc_vga_i2c_driver = {
+	.driver = {
+		   .name = "mxc_vga_i2c",
+	},
+	.probe = mxc_vga_i2c_probe,
+	.remove = mxc_vga_i2c_remove,
+	.id_table = mxc_vga_i2c_id,
+};
+
+static int __init mxc_vga_i2c_init(void)
+{
+	return i2c_add_driver(&mxc_vga_i2c_driver);
+}
+
+static void __exit mxc_vga_i2c_exit(void)
+{
+	i2c_del_driver(&mxc_vga_i2c_driver);
+}
+
+module_init(mxc_vga_i2c_init);
+module_exit(mxc_vga_i2c_exit);
+#endif
+#endif
+
+
 struct mxc_lcd_platform_data {
 	u32 default_ifmt;
 	u32 ipu_id;
@@ -74,6 +356,14 @@ static int lcdif_init(struct mxc_dispdrv_handle *disp,
 		setting->if_fmt = plat_data->default_ifmt;
 	}
 
+#if defined(CONFIG_ARCH_ADVANTECH) && defined(CONFIG_FB_MXC_SYNC_PANEL_EDID)
+	task_kthread = kthread_run(vga_edid_work, NULL, "vga_edid_work");
+	if (IS_ERR(task_kthread))
+	{
+		ret = PTR_ERR(task_kthread);
+		printk(KERN_INFO "kthread is  NOT created!!\n");
+	}
+#else
 	INIT_LIST_HEAD(&setting->fbi->modelist);
 	for (i = 0; i < modedb_sz; i++) {
 		struct fb_videomode m;
@@ -84,6 +374,7 @@ static int lcdif_init(struct mxc_dispdrv_handle *disp,
 			break;
 		}
 	}
+#endif
 
 	return ret;
 }
diff --git a/drivers/video/fbdev/mxc/mxcfb_ch7055.c b/drivers/video/fbdev/mxc/mxcfb_ch7055.c
new file mode 100644
index 0000000..f6369bf
--- /dev/null
+++ b/drivers/video/fbdev/mxc/mxcfb_ch7055.c
@@ -0,0 +1,150 @@
+#ifdef CONFIG_ARCH_ADVANTECH
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb_epson_vga.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+#include <linux/mxcfb.h>
+#include <linux/ipu.h>
+#include <linux/fsl_devices.h>
+//#include <hardware.h>
+
+static struct i2c_client *ch7055_client;
+
+static ssize_t ch7055_show_brightness(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{	
+	unsigned long val;
+	val = i2c_smbus_read_byte_data(ch7055_client, 0x04);
+	
+	return sprintf(buf, "%lu\n", val);
+}
+
+static ssize_t ch7055_store_brightness(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	unsigned long val;
+	int ret;
+
+	if ((kstrtoul(buf, 10, &val) < 0) ||
+	    (val > 127))
+		return -EINVAL;
+  
+	ret = i2c_smbus_write_byte_data(ch7055_client, 0x04, val);
+	ret = i2c_smbus_write_byte_data(ch7055_client, 0x05, val);
+	ret = i2c_smbus_write_byte_data(ch7055_client, 0x06, val);
+
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static DEVICE_ATTR(brightness, S_IWUSR | S_IRUGO,
+		   ch7055_show_brightness, ch7055_store_brightness);
+
+static struct attribute *ch7055_attributes[] = {
+	&dev_attr_brightness.attr,
+	NULL
+};
+
+static const struct attribute_group ch7055_attr_group = {
+	.attrs = ch7055_attributes,
+};
+
+static int ch7055_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	int err, ret;
+	ch7055_client = client;	
+	
+	/* setup default brightness */
+	ret = i2c_smbus_write_byte_data(ch7055_client, 0x04, 0x40);
+	ret = i2c_smbus_write_byte_data(ch7055_client, 0x05, 0x40);
+	ret = i2c_smbus_write_byte_data(ch7055_client, 0x06, 0x40);
+	if (ret < 0)
+		return ret;
+	
+	/* register sys hook */
+	err = sysfs_create_group(&client->dev.kobj, &ch7055_attr_group);
+	if (err)
+		goto exit_kfree;
+	
+	exit_kfree:		
+	return 0;
+}
+
+static int ch7055_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id ch7055_id[] = {
+	{"ch7055", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, ch7055_id);
+
+static struct i2c_driver ch7055_driver = {
+	.driver = {
+		   .name = "ch7055",
+		   },
+	.probe = ch7055_probe,
+	.remove = ch7055_remove,
+	.id_table = ch7055_id,
+};
+
+static int __init ch7055_init(void)
+{
+	printk("ch7055_init\n");	
+	return i2c_add_driver(&ch7055_driver);
+}
+
+static void __exit ch7055_exit(void)
+{
+	i2c_del_driver(&ch7055_driver);
+}
+
+module_init(ch7055_init);
+module_exit(ch7055_exit);
+
+MODULE_DESCRIPTION("CH7055 VGA driver");
+MODULE_LICENSE("GPL");
+
+#endif
-- 
1.7.9.5

