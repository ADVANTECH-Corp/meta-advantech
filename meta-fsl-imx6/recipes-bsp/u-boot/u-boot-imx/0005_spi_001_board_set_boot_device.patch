From ad38a531c8da1d1fe3eb45fa9b82b0add902fe40 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Wed, 6 Jan 2016 17:22:59 +0800
Subject: [PATCH] common/board_r.c


diff --git a/common/board_r.c b/common/board_r.c
index 1d5059c..288fb9c 100755
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -814,6 +814,103 @@ static int initr_check_fastboot(void)
 }
 #endif
 
+#ifdef CONFIG_ADVANTECH
+int check_emmc_exist(void)
+{
+        struct mmc *mmc = find_mmc_device(1);
+        int result=0;
+        if (mmc) {
+                result = mmc_init(mmc);
+                if(result != 0) {
+                        printf("*** emmc cannot init, emmc device doesn't exist\n");
+                        return 0;
+                }
+                return 1;
+        } else{
+                return 0;
+        }
+}
+
+int board_set_boot_device(void)
+{
+	char buf[256];
+	char advboot_version[128];
+	char uboot_version[128];
+	char *pch,*s;
+	 
+	int dev = (*(int *)0x22200000);
+	int emmc_exist = 0;
+
+	/* log uboot version */
+	strncpy(advboot_version, (void *)0x22300000, 128);
+
+	if (strstr(advboot_version,"advantech") == NULL)
+		strcpy(advboot_version, "");
+
+	pch=strchr(version_string,'2');
+	if (pch!=NULL)
+	{
+		s=strchr(pch,' ');
+		strncpy(uboot_version, pch, s-pch);
+		uboot_version[s-pch]='\0';
+	}
+
+	sprintf(buf, "advboot_version=%s uboot_version=%s", advboot_version, uboot_version);
+	setenv("bootargs", buf);
+
+	// check emmc exists or not
+	emmc_exist = check_emmc_exist();
+
+	switch(dev)
+	{
+		case 1:
+		default:
+			/* booting from SD*/
+			printf("booting from SD\n");
+			setenv("mmcdev", "0");
+			if(emmc_exist) {
+				sprintf(buf, "/dev/mmcblk1p2 rootwait rw");
+				setenv("mmcroot",buf);
+			}
+			break;
+		case 2:
+			/* booting from SATA*/
+			printf("booting from SATA\n");
+			sprintf(buf, "fatload sata 0:1 ${loadaddr} ${image}");
+			setenv("loadimage", buf);
+			sprintf(buf, "fatload sata 0:1 ${fdt_addr} ${fdt_file}");
+			setenv("loadfdt", buf);
+			sprintf(buf, "fatload sata 0:1 ${loadaddr} ${script}");
+			setenv("loadbootscript", buf);
+			sprintf(buf, "/dev/sda2 rootwait rw");
+			setenv("sataroot", buf);
+			sprintf(buf, "setenv bootargs console=${console},${baudrate} ${smp} root=${sataroot} ${bootargs}");
+			setenv("sataargs", buf);
+			sprintf(buf, "dcache off; sata init; run loadimage; run loadbootscript; run sataargs; run loadfdt; bootz ${loadaddr} - ${fdt_addr}");
+			setenv("bootcmd", buf);
+			break;
+		case 3:
+			/* booting from iNAND*/
+			printf("booting from iNAND\n");
+			setenv("mmcdev", "1");
+			break;
+#ifdef CONFIG_SPI_BOOT
+		case 4:
+			/* booting from SPI*/
+			printf("booting from SPI -> kernel boot form EMMC\n");
+			if(emmc_exist) 	setenv("mmcdev", "1");
+			break;
+#endif
+	}
+
+	/*record ddr bit, 32 or 64 bit*/
+	sprintf(buf, "%d", *(unsigned int *)0x22500000);
+	setenv("ddr_bit", buf);
+
+	return 0;
+}
+#endif /* CONFIG_ADVANTECH */
+
 static int run_main_loop(void)
 {
 #ifdef CONFIG_SANDBOX
@@ -1040,6 +1137,9 @@ init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_FASTBOOT
 	initr_check_fastboot,
 #endif
+#ifdef CONFIG_ADVANTECH
+	board_set_boot_device,
+#endif
 	run_main_loop,
 };
 
-- 
1.7.9.5

