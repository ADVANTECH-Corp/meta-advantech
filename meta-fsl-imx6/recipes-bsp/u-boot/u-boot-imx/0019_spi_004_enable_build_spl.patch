From 4d7fb26fbd371c65fdca1c58f654660b13b3cf3d Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Fri, 5 Feb 2016 11:07:50 +0800
Subject: [PATCH] spl4


diff --git a/common/spl/Makefile b/common/spl/Makefile
index 10a4589..629e640 100644
--- a/common/spl/Makefile
+++ b/common/spl/Makefile
@@ -9,13 +9,21 @@
 #
 
 ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_ADVANTECH
+obj-$(CONFIG_SPL_FRAMEWORK) += spl_advantech.o
+else
 obj-$(CONFIG_SPL_FRAMEWORK) += spl.o
+endif
 obj-$(CONFIG_SPL_NOR_SUPPORT) += spl_nor.o
 obj-$(CONFIG_SPL_YMODEM_SUPPORT) += spl_ymodem.o
 obj-$(CONFIG_SPL_NAND_SUPPORT) += spl_nand.o
 obj-$(CONFIG_SPL_ONENAND_SUPPORT) += spl_onenand.o
 obj-$(CONFIG_SPL_NET_SUPPORT) += spl_net.o
+ifdef CONFIG_ADVANTECH
+obj-$(CONFIG_SPL_MMC_SUPPORT) += spl_mmc_advantech.o
+else
 obj-$(CONFIG_SPL_MMC_SUPPORT) += spl_mmc.o
+endif
 obj-$(CONFIG_SPL_USB_SUPPORT) += spl_usb.o
 obj-$(CONFIG_SPL_FAT_SUPPORT) += spl_fat.o
 obj-$(CONFIG_SPL_EXT_SUPPORT) += spl_ext.o
diff --git a/common/spl/spl_advantech.c b/common/spl/spl_advantech.c
new file mode 100755
index 0000000..cf255bf
--- /dev/null
+++ b/common/spl/spl_advantech.c
@@ -0,0 +1,378 @@
+/*
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ *
+ * Aneesh V <aneesh@ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <dm.h>
+#include <spl.h>
+#include <asm/u-boot.h>
+#include <nand.h>
+#include <fat.h>
+#include <version.h>
+#include <i2c.h>
+#include <image.h>
+#include <malloc.h>
+#include <dm/root.h>
+#include <linux/compiler.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_SYS_UBOOT_START
+#define CONFIG_SYS_UBOOT_START	CONFIG_SYS_TEXT_BASE
+#endif
+#ifndef CONFIG_SYS_MONITOR_LEN
+/* Unknown U-Boot size, let's assume it will not be more than 200 KB */
+#define CONFIG_SYS_MONITOR_LEN	(200 * 1024)
+#endif
+
+u32 *boot_params_ptr = NULL;
+struct spl_image_info spl_image;
+
+#if defined(CONFIG_ADVANTECH)
+#define SPL_VERSION_STRING "Adv-Boot SPL " PLAIN_VERSION " (" U_BOOT_DATE " - " \
+                        U_BOOT_TIME ")\n"
+
+const char __weak version_string[] = SPL_VERSION_STRING;
+#endif
+/* Define board data structure */
+static bd_t bdata __attribute__ ((section(".data")));
+
+/*
+ * Default function to determine if u-boot or the OS should
+ * be started. This implementation always returns 1.
+ *
+ * Please implement your own board specific funcion to do this.
+ *
+ * RETURN
+ * 0 to not start u-boot
+ * positive if u-boot should start
+ */
+#ifdef CONFIG_SPL_OS_BOOT
+__weak int spl_start_uboot(void)
+{
+	puts("SPL: Please implement spl_start_uboot() for your board\n");
+	puts("SPL: Direct Linux boot not active!\n");
+	return 1;
+}
+#endif
+
+/*
+ * Weak default function for board specific cleanup/preparation before
+ * Linux boot. Some boards/platforms might not need it, so just provide
+ * an empty stub here.
+ */
+__weak void spl_board_prepare_for_linux(void)
+{
+	/* Nothing to do! */
+}
+
+void spl_set_header_raw_uboot(void)
+{
+	spl_image.size = CONFIG_SYS_MONITOR_LEN;
+	spl_image.entry_point = CONFIG_SYS_UBOOT_START;
+	spl_image.load_addr = CONFIG_SYS_TEXT_BASE;
+	spl_image.os = IH_OS_U_BOOT;
+	spl_image.name = "U-Boot";
+}
+
+void spl_parse_image_header(const struct image_header *header)
+{
+	u32 header_size = sizeof(struct image_header);
+
+	if (image_get_magic(header) == IH_MAGIC) {
+		if (spl_image.flags & SPL_COPY_PAYLOAD_ONLY) {
+			/*
+			 * On some system (e.g. powerpc), the load-address and
+			 * entry-point is located at address 0. We can't load
+			 * to 0-0x40. So skip header in this case.
+			 */
+			spl_image.load_addr = image_get_load(header);
+			spl_image.entry_point = image_get_ep(header);
+			spl_image.size = image_get_data_size(header);
+		} else {
+			spl_image.entry_point = image_get_load(header);
+			/* Load including the header */
+			spl_image.load_addr = spl_image.entry_point -
+				header_size;
+			spl_image.size = image_get_data_size(header) +
+				header_size;
+		}
+		spl_image.os = image_get_os(header);
+		spl_image.name = image_get_name(header);
+		debug("spl: payload image: %.*s load addr: 0x%x size: %d\n",
+			(int)sizeof(spl_image.name), spl_image.name,
+			spl_image.load_addr, spl_image.size);
+	} else {
+#ifdef CONFIG_SPL_PANIC_ON_RAW_IMAGE
+		/*
+		 * CONFIG_SPL_PANIC_ON_RAW_IMAGE is defined when the
+		 * code which loads images in SPL cannot guarantee that
+		 * absolutely all read errors will be reported.
+		 * An example is the LPC32XX MLC NAND driver, which
+		 * will consider that a completely unreadable NAND block
+		 * is bad, and thus should be skipped silently.
+		 */
+		panic("** no mkimage signature but raw image not supported");
+#else
+		/* Signature not found - assume u-boot.bin */
+		debug("mkimage signature not found - ih_magic = %x\n",
+			header->ih_magic);
+		spl_set_header_raw_uboot();
+#endif
+	}
+}
+
+__weak void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
+{
+	typedef void __noreturn (*image_entry_noargs_t)(void);
+
+	image_entry_noargs_t image_entry =
+			(image_entry_noargs_t) spl_image->entry_point;
+
+	debug("image entry point: 0x%X\n", spl_image->entry_point);
+	image_entry();
+}
+
+#ifdef CONFIG_SPL_RAM_DEVICE
+static void spl_ram_load_image(void)
+{
+	const struct image_header *header;
+
+	/*
+	 * Get the header.  It will point to an address defined by handoff
+	 * which will tell where the image located inside the flash. For
+	 * now, it will temporary fixed to address pointed by U-Boot.
+	 */
+	header = (struct image_header *)
+		(CONFIG_SYS_TEXT_BASE -	sizeof(struct image_header));
+
+	spl_parse_image_header(header);
+}
+#endif
+
+void board_init_r(gd_t *dummy1, ulong dummy2)
+{
+	u32 boot_device;
+	debug(">>spl:board_init_r()\n");
+
+#if defined(CONFIG_SYS_SPL_MALLOC_START)
+	mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START,
+			CONFIG_SYS_SPL_MALLOC_SIZE);
+	gd->flags |= GD_FLG_FULL_MALLOC_INIT;
+#elif defined(CONFIG_SYS_MALLOC_F_LEN)
+	gd->malloc_limit = gd->malloc_base + CONFIG_SYS_MALLOC_F_LEN;
+	gd->malloc_ptr = 0;
+#endif
+#ifdef CONFIG_SPL_DM
+	dm_init_and_scan(true);
+#endif
+
+#ifndef CONFIG_PPC
+	/*
+	 * timer_init() does not exist on PPC systems. The timer is initialized
+	 * and enabled (decrementer) in interrupt_init() here.
+	 */
+	timer_init();
+#endif
+
+#ifdef CONFIG_SPL_BOARD_INIT
+	spl_board_init();
+#endif
+
+	boot_device = spl_boot_device();
+	debug("boot device - %d\n", boot_device);
+	switch (boot_device) {
+#if defined(CONFIG_ADVANTECH)
+	case BOOT_DEVICE_AUTO:
+		printf("BOOT_DEVICE_AUTO\n");
+#ifdef CONFIG_SPL_MMC_SUPPORT
+		/* 1. SD card */
+		if (!spl_mmc_load_image(0)) {
+			printf("booting from SD\n");
+			*(int *)0x22200000 = 0x01;
+		} else
+#endif
+#ifdef CONFIG_SPL_SATA_SUPPORT
+		/* 2. SATA disk */
+		if (!spl_sata_load_image(0)) {
+			printf("booting from SATA\n");
+			*(int *)0x22200000 = 0x02;
+		} else
+#endif
+#ifdef CONFIG_SPL_MMC_SUPPORT
+		/* 3. eMMC flash */
+		if(!spl_mmc_load_image(1)) {
+			printf("booting from iNAND\n");
+			*(int *)0x22200000 = 0x03;
+		} else
+#endif
+		{
+			printf("SPL: No bootable device is found!\n");
+			hang();
+		}
+		break;
+#ifdef CONFIG_SPL_SATA_SUPPORT
+	case BOOT_DEVICE_SATA:
+		printf("BOOT_DEVICE_SATA\n");
+		spl_sata_load_image(0);
+		break;
+#endif
+#endif /* CONFIG_ADVANTECH */
+#ifdef CONFIG_SPL_RAM_DEVICE
+	case BOOT_DEVICE_RAM:
+		printf("BOOT_DEVICE_RAM\n");
+		spl_ram_load_image();
+		break;
+#endif
+#ifdef CONFIG_SPL_MMC_SUPPORT
+#if defined(CONFIG_ADVANTECH)
+	case BOOT_DEVICE_MMC1:
+		printf("BOOT_DEVICE_MMC1\n");
+		spl_mmc_load_image(0);
+		break;
+	case BOOT_DEVICE_MMC2:
+		printf("BOOT_DEVICE_MMC2\n");
+		spl_mmc_load_image(1);
+		break;
+	case BOOT_DEVICE_MMC2_2:
+		printf("BOOT_DEVICE_MMC2_2\n");
+		/* Do nothing */
+		break;
+#else
+	case BOOT_DEVICE_MMC1:
+	case BOOT_DEVICE_MMC2:
+	case BOOT_DEVICE_MMC2_2:
+		printf("BOOT_DEVICE_MMC\n");
+		spl_mmc_load_image();
+		break;
+#endif
+#endif
+#ifdef CONFIG_SPL_NAND_SUPPORT
+	case BOOT_DEVICE_NAND:
+		printf("BOOT_DEVICE_NAND\n");
+		spl_nand_load_image();
+		break;
+#endif
+#ifdef CONFIG_SPL_ONENAND_SUPPORT
+	case BOOT_DEVICE_ONENAND:
+		printf("BOOT_DEVICE_ONENAND\n");
+		spl_onenand_load_image();
+		break;
+#endif
+#ifdef CONFIG_SPL_NOR_SUPPORT
+	case BOOT_DEVICE_NOR:
+		printf("BOOT_DEVICE_NOR\n");
+		spl_nor_load_image();
+		break;
+#endif
+#ifdef CONFIG_SPL_YMODEM_SUPPORT
+	case BOOT_DEVICE_UART:
+		printf("BOOT_DEVICE_UART\n");
+		spl_ymodem_load_image();
+		break;
+#endif
+#ifdef CONFIG_SPL_SPI_SUPPORT
+	case BOOT_DEVICE_SPI:
+		printf("BOOT_DEVICE_SPI\n");
+		spl_spi_load_image();
+		break;
+#endif
+#ifdef CONFIG_SPL_ETH_SUPPORT
+	case BOOT_DEVICE_CPGMAC:
+		printf("BOOT_DEVICE_CPGMAC\n");
+#ifdef CONFIG_SPL_ETH_DEVICE
+		spl_net_load_image(CONFIG_SPL_ETH_DEVICE);
+#else
+		spl_net_load_image(NULL);
+#endif
+		break;
+#endif
+#ifdef CONFIG_SPL_USBETH_SUPPORT
+	case BOOT_DEVICE_USBETH:
+		printf("BOOT_DEVICE_USBETH\n");
+		spl_net_load_image("usb_ether");
+		break;
+#endif
+	default:
+		printf("SPL: Un-supported Boot Device\n");
+		hang();
+	}
+
+	switch (spl_image.os) {
+	case IH_OS_U_BOOT:
+		printf("Jumping to U-Boot\n");
+		break;
+#ifdef CONFIG_SPL_OS_BOOT
+	case IH_OS_LINUX:
+		printf("Jumping to Linux\n");
+		spl_board_prepare_for_linux();
+		jump_to_image_linux((void *)CONFIG_SYS_SPL_ARGS_ADDR);
+#endif
+	default:
+		printf("Unsupported OS image.. Jumping nevertheless..\n");
+	}
+	jump_to_image_no_args(&spl_image);
+}
+
+/*
+ * This requires UART clocks to be enabled.  In order for this to work the
+ * caller must ensure that the gd pointer is valid.
+ */
+void preloader_console_init(void)
+{
+	gd->bd = &bdata;
+	gd->baudrate = CONFIG_BAUDRATE;
+
+	serial_init();		/* serial communications setup */
+
+	gd->have_console = 1;
+
+#if defined(CONFIG_ADVANTECH)
+	puts("\n\n" SPL_VERSION_STRING);
+#else
+	puts("\nU-Boot SPL " PLAIN_VERSION " (" U_BOOT_DATE " - " \
+			U_BOOT_TIME ")\n");
+#endif
+#ifdef CONFIG_SPL_DISPLAY_PRINT
+	spl_display_print();
+#endif
+}
+
+/**
+ * spl_relocate_stack_gd() - Relocate stack ready for board_init_r() execution
+ *
+ * Sometimes board_init_f() runs with a stack in SRAM but we want to use SDRAM
+ * for the main board_init_r() execution. This is typically because we need
+ * more stack space for things like the MMC sub-system.
+ *
+ * This function calculates the stack position, copies the global_data into
+ * place and returns the new stack position. The caller is responsible for
+ * setting up the sp register.
+ *
+ * @return new stack location, or 0 to use the same stack
+ */
+ulong spl_relocate_stack_gd(void)
+{
+#ifdef CONFIG_SPL_STACK_R
+	gd_t *new_gd;
+	ulong ptr;
+
+	/* Get stack position: use 8-byte alignment for ABI compliance */
+	ptr = CONFIG_SPL_STACK_R - sizeof(gd_t);
+	ptr &= ~7;
+	new_gd = (gd_t *)ptr;
+	memcpy(new_gd, (void *)gd, sizeof(gd_t));
+	gd = new_gd;
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	return ptr;
+#else
+	return 0;
+#endif
+}
diff --git a/common/spl/spl_mmc_advantech.c b/common/spl/spl_mmc_advantech.c
new file mode 100755
index 0000000..8358daa
--- /dev/null
+++ b/common/spl/spl_mmc_advantech.c
@@ -0,0 +1,182 @@
+/*
+ * (C) Copyright 2014 Advantech Co. <risc-sw@advantech.com.tw>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <spl.h>
+#include <asm/u-boot.h>
+#include <asm/utils.h>
+#include <mmc.h>
+#include <fat.h>
+#include <version.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int spl_mmc_check_crc(unsigned int dev, struct mmc *mmc)
+{
+#ifdef CONFIG_SPL_FAT_SUPPORT
+	/* Needs to implement later */
+#else
+	u32 n;
+	/* read crc file */
+	char tag[512];
+	char crc[512];
+	
+	n = mmc->block_dev.block_read(dev, 0x02, 1, (void *) 0x22100000);
+	if(n != 1)
+		return 1;
+	
+	memcpy(tag, (void *) 0x22100000, 512);
+	//tag[9] = '\0';
+	//printf("crc file %s\n", tag);
+	
+	/* make uboot crc */
+	n = mmc->block_dev.block_read(dev, 0x03, 0x4b0, (void *) 0x22000000);
+	if(n != 0x4b0)
+		return 1;
+	
+	*(int *)0x21f00000 = crc32 (0, (const uchar *) 0x22000000, 0x96000);
+	sprintf(crc, "%08x", *(int *)0x21f00000);
+	//crc[9] = '\0';
+	//printf("uboot crc %s\n", crc);
+	
+	/* verrify crc */
+	if(memcmp(tag, crc, 8))
+	{
+		printf("spl: mmc dev %d - crc error\n", dev);
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+static int mmc_load_image_raw(unsigned int dev, struct mmc *mmc)
+{
+	u32 image_size_sectors, err;
+	const struct image_header *header;
+
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
+						sizeof(struct image_header));
+
+	/* read image header to find the image size & load address */
+	err = mmc->block_dev.block_read(dev,
+			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR, 1,
+			(void *)header);
+
+	if (err <= 0)
+		goto end;
+
+	spl_parse_image_header(header);
+
+	/* convert size to sectors - round up */
+	image_size_sectors = (spl_image.size + mmc->read_bl_len - 1) /
+				mmc->read_bl_len;
+
+	/* Read the header too to avoid extra memcpy */
+	err = mmc->block_dev.block_read(dev,
+			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR,
+			image_size_sectors, (void *)spl_image.load_addr);
+
+	printf("MMC read: dev # %d, block # %d,""count %d ... \n",
+		dev, CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR, image_size_sectors);
+end:
+	if (err <= 0) {
+		printf("spl: mmc blk read err - %d\n", err);
+		return 1;
+	} else
+		return 0;
+}
+
+#ifdef CONFIG_SPL_FAT_SUPPORT
+static int mmc_load_image_fat(struct mmc *mmc)
+{
+	s32 err;
+	struct image_header *header;
+
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
+						sizeof(struct image_header));
+
+	err = fat_register_device(&mmc->block_dev,
+				CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION);
+	if (err) {
+		printf("spl: fat register err - %d\n", err);
+		return 1;
+	}
+
+	err = file_fat_read(CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME,
+				(u8 *)header, sizeof(struct image_header));
+	if (err <= 0)
+		goto end;
+
+	spl_parse_image_header(header);
+
+	err = file_fat_read(CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME,
+				(u8 *)spl_image.load_addr, 0);
+
+end:
+	if (err <= 0) {
+		printf("spl: error reading image %s, err - %d\n",
+			CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME, err);
+		return 1;
+	} else
+		return 0;
+}
+#endif
+
+int spl_mmc_load_image(unsigned int dev)
+{
+	struct mmc *mmc;
+	int err;
+	u32 boot_mode;
+
+	mmc_initialize(gd->bd);
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc) {
+		puts("spl: mmc device not found!!\n");
+		return 1;
+	}
+
+	err = mmc_init(mmc);
+	if (err) {
+		printf("spl: mmc dev %d init failed\n", dev);
+		return 1;
+	}
+
+	err = spl_mmc_check_crc(dev, mmc);
+	if (err) {
+		return 1;
+	}
+
+	boot_mode = spl_boot_mode();
+	if (boot_mode == MMCSD_MODE_RAW) {
+		debug("boot mode - RAW\n");
+		return mmc_load_image_raw(dev, mmc);
+#ifdef CONFIG_SPL_FAT_SUPPORT
+	} else if (boot_mode == MMCSD_MODE_FAT) {
+		debug("boot mode - FAT\n");
+		return mmc_load_image_fat(mmc);
+#endif
+	} else {
+		puts("spl: wrong MMC boot mode\n");
+		return 1;
+	}
+}
-- 
1.7.9.5

